# -*- coding: utf-8 -*-
"""BrianSingh_Module4_Data608.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11IhclPBUGKR1Qdld798Wl7djSgMEpc_v
"""

import pandas as pd
import numpy as np

"""This module we'll be looking at the New York City tree census. This data was provided by a volunteer driven census in 2015, and we'll be accessing it via the socrata API. The main site for the data is [here](https://data.cityofnewyork.us/Environment/2015-Street-Tree-Census-Tree-Data/uvpi-gqnh), and on the upper right hand side you'll be able to see the link to the API.

The data is conveniently available in json format, so we should be able to just read it directly in to Pandas:
"""

url = 'https://data.cityofnewyork.us/resource/nwxe-4ae8.json'
trees = pd.read_json(url)
trees.head(10)

"""Looks good, but lets take a look at the shape of this data:"""

trees.shape

"""1000 seems like too few trees for a city like New York, and a suspiciously round number. What's going on?

Socrata places a 1000 row limit on their API. Raw data is meant to be "paged" through for applications, with the expectation that a UX wouldn't be able to handle a full dataset. 

As a simple example, if we had a mobile app with limited space that only displayed trees 5 at a time, we could view the first 5 trees in the dataset with the url below:
"""

firstfive_url = 'https://data.cityofnewyork.us/resource/nwxe-4ae8.json?$limit=5&$offset=0'
firstfive_trees = pd.read_json(firstfive_url)
firstfive_trees

"""If we wanted the next 5, we would use this url:"""

nextfive_url = 'https://data.cityofnewyork.us/resource/nwxe-4ae8.json?$limit=5&$offset=5'
nextfive_trees = pd.read_json(nextfive_url)
nextfive_trees

"""You can read more about paging using the Socrata API [here](https://dev.socrata.com/docs/paging.html)

In these docs, you'll also see more advanced functions (called `SoQL`) under the "filtering and query" section. These functions should be reminding you of SQL.

Think about the shape you want your data to be in before querying it. Using `SoQL` is a good way to avoid the limits of the API. For example, using the below query I can easily obtain the count of each species of tree in the Bronx:
"""

boro = 'Bronx'
soql_url = ('https://data.cityofnewyork.us/resource/nwxe-4ae8.json?' +\
        '$select=spc_common,count(tree_id)' +\
        '&$where=boroname=\'Bronx\'' +\
        '&$group=spc_common').replace(' ', '%20')
soql_trees = pd.read_json(soql_url)

soql_trees

"""This behavior is very common with web APIs, and I think this is useful when thinking about building interactive data products. When in a Jupyter Notebook or RStudio, there's an expectation that (unless you're dealing with truly large datasets) the data you want can be brought in memory and manipulated.

Dash and Shiny abstract away the need to distinguish between client side and server side to make web development more accessible to data scientists. This can lead to some unintentional design mistakes if you don't think about how costly your callback functions are (for example: nothing will stop you in dash from running a costly model triggered whenever a dropdown is called.)

The goal of using the Socrata is to force you to think about where your data operations are happening, and not resort to pulling in the data and performing all operations in local memory.

----------

**NOTE**: One tip in dealing with URLs: you may need to replace spaces with `'%20'`. I personally just write out the url and then follow the string with a replace:
"""

'https://api-url.com/?query with spaces'.replace(' ', '%20')

#install Dash
!pip install jupyter-dash

from dash import Dash, html, dcc
import plotly.express as px

soql_url_assignment4 = ('https://data.cityofnewyork.us/resource/nwxe-4ae8.json?' +\
        '$select=health,count(tree_id)' +\
        '&$group=health').replace(' ', '%20')
soql_trees_assignment4 = pd.read_json(soql_url_assignment4)

soql_trees_assignment4

soql_url_assignment4 = ('https://data.cityofnewyork.us/resource/nwxe-4ae8.json?' +\
        '$select=health,spc_common,boroname,steward').replace(' ', '%20')
soql_trees_assignment4 = pd.read_json(soql_url_assignment4)

soql_trees_assignment4['health']=soql_trees_assignment4.health.fillna('Unknown')

print(soql_trees_assignment4)

soql_trees_assignment4['steward'].unique()

!pip uninstall dash
!pip install dash

!pip install jupyter-dash

"""## 1. What proportion of trees are in good, fair, or poor health according to the ‘health’ variable ?"""

import pandas as pd
import numpy as np
import dash
import dash_core_components as dcc
import dash_html_components as html
import plotly.express as px
from jupyter_dash import JupyterDash
from dash.dependencies import Input, Output
from dash import dash_table, Input, Output

soql_url_assignment4 = ('https://data.cityofnewyork.us/resource/nwxe-4ae8.json?' +\
        '$select=health,spc_common,boroname,steward').replace(' ', '%20')
soql_trees_assignment4 = pd.read_json(soql_url_assignment4)

soql_trees_assignment4=soql_trees_assignment4.dropna()
soql_trees_assignment4_b = soql_trees_assignment4.groupby(["health","boroname","spc_common"])["health"].count().reset_index(name="count")
soql_trees_assignment4_b['Percentage'] = 100 * soql_trees_assignment4_b['count']  / soql_trees_assignment4_b['count'].sum()
soql_trees_assignment4_b

#dash
app = JupyterDash(__name__)
#fig = px.histogram(soql_trees_assignment4, x="health", color="spc_common", barmode="group")
app.layout = html.Div(children=[
    html.H1(children='Brian Singh_Assignment4_Data608_Question1'),

    html.Div(children='''
        Please select a tree species.
    '''),
        
        
        dcc.Dropdown(
            soql_trees_assignment4['spc_common'].unique(),
            id='spc',
            value=soql_trees_assignment4.spc_common.values,
        ),

        dcc.Dropdown(
            soql_trees_assignment4['boroname'].unique(),
            id='boro',
            value=soql_trees_assignment4.boroname.values,
        ),

    dcc.Graph(
        id='graph',
        figure=fig
    ),

    dash_table.DataTable(id="table")
    #dash_table.DataTable(id="table",
     #                   columns=[{'name':i,"id":i} for i in soql_trees_assignment4_b.columns],
      #                   data= soql_trees_assignment4_b.to_dict('records')),

    #dcc.Graph(figure = px.histogram(soql_trees_assignment4, x="health", color="spc_common", barmode="group"))
])

@app.callback(
    Output('graph','figure'),
    #Output('table','data'), #new
    Input('spc','value'),
    Input('boro','value')
)

def update_graph(spc,boro):
  df = soql_trees_assignment4
  fig = px.histogram(df, x=df["health"].loc[(df["spc_common"]==spc) & (df["boroname"]==boro)])
  return fig

@app.callback(
    Output('table','data'), #new
    Input('spc','value'),
    Input('boro','value')
)

def update_table(spc,boro):
  #df2 = soql_trees_assignment4
  tbl = soql_trees_assignment4_b[(soql_trees_assignment4_b.spc_common.isin(spc)) & (soql_trees_assignment4_b.boroname.isin(boro))]
  #tbl = dash_table.DataTable(columns=[{'name':i,"id":i} for i in df2.loc[(df2["spc_common"]==spc) & (df2["boroname"]==boro)].columns],
  #                       data= df2.to_dict('records'))
  return tbl.to_dict('records')

#if __name__ == '__main__':
app.run_server(mode='inline')

"""I was having trouble in the code above having the Dash Table update with the dropdown filters as the graph updated. I saw this code on https://dash.plotly.com/datatable/callbacks and implemented using this dataset. It isn't formatted ideally, but it gets me in the direction I was aiming for. The table allows for filtering and updates the graphs accordingly."""

#working2

import pandas as pd
import numpy as np
import dash
import dash_core_components as dcc
import dash_html_components as html
import plotly.express as px
from jupyter_dash import JupyterDash
from dash.dependencies import Input, Output
from dash import dash_table, Input, Output

soql_url_assignment4 = ('https://data.cityofnewyork.us/resource/nwxe-4ae8.json?' +\
        '$select=health,spc_common,boroname,steward').replace(' ', '%20')
soql_trees_assignment4 = pd.read_json(soql_url_assignment4)

soql_trees_assignment4=soql_trees_assignment4.dropna()
soql_trees_assignment4_b = soql_trees_assignment4.groupby(["health","boroname","spc_common"])["health"].count().reset_index(name="count")
soql_trees_assignment4_b['Percentage'] = 100 * soql_trees_assignment4_b['count']  / soql_trees_assignment4_b['count'].sum()
soql_trees_assignment4_b

#dash
app = JupyterDash(__name__)
#fig = px.histogram(soql_trees_assignment4, x="health", color="spc_common", barmode="group")
app.layout = html.Div(
    className="row",
    children=[
        html.Div(
            dash_table.DataTable(
                id='table-paging-with-graph',
                columns=[
                    {"name": i, "id": i} for i in sorted(soql_trees_assignment4_b.columns)
                ],
                page_current=0,
                page_size=20,
                page_action='custom',

                filter_action='custom',
                filter_query='',

                sort_action='custom',
                sort_mode='multi',
                sort_by=[]
            ),
            style={'height': 750, 'overflowY': 'scroll'},
            className='six columns'
        ),
        html.Div(
            id='table-paging-with-graph-container',
            className="five columns"
        )
    ]
)

operators = [['ge ', '>='],
             ['le ', '<='],
             ['lt ', '<'],
             ['gt ', '>'],
             ['ne ', '!='],
             ['eq ', '='],
             ['contains '],
             ['datestartswith ']]


def split_filter_part(filter_part):
    for operator_type in operators:
        for operator in operator_type:
            if operator in filter_part:
                name_part, value_part = filter_part.split(operator, 1)
                name = name_part[name_part.find('{') + 1: name_part.rfind('}')]

                value_part = value_part.strip()
                v0 = value_part[0]
                if (v0 == value_part[-1] and v0 in ("'", '"', '`')):
                    value = value_part[1: -1].replace('\\' + v0, v0)
                else:
                    try:
                        value = float(value_part)
                    except ValueError:
                        value = value_part

                # word operators need spaces after them in the filter string,
                # but we don't want these later
                return name, operator_type[0].strip(), value

    return [None] * 3


@app.callback(
    Output('table-paging-with-graph', "data"),
    Input('table-paging-with-graph', "page_current"),
    Input('table-paging-with-graph', "page_size"),
    Input('table-paging-with-graph', "sort_by"),
    Input('table-paging-with-graph', "filter_query"))
def update_table(page_current, page_size, sort_by, filter):
    filtering_expressions = filter.split(' && ')
    dff = soql_trees_assignment4_b
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in ('eq', 'ne', 'lt', 'le', 'gt', 'ge'):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == 'contains':
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == 'datestartswith':
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [col['column_id'] for col in sort_by],
            ascending=[
                col['direction'] == 'asc'
                for col in sort_by
            ],
            inplace=False
        )

    return dff.iloc[
        page_current*page_size: (page_current + 1)*page_size
    ].to_dict('records')


@app.callback(
    Output('table-paging-with-graph-container', "children"),
    Input('table-paging-with-graph', "data"))
def update_graph(rows):
    dff = pd.DataFrame(rows)
    return html.Div(
        [
            dcc.Graph(
                id=column,
                figure={
                    "data": [
                        {
                            "x": dff["health"],
                            "y": dff[column] if column in dff else [],
                            "type": "bar",
                            "marker": {"color": "#0074D9"},
                        }
                    ],
                    "layout": {
                        "xaxis": {"automargin": True},
                        "yaxis": {"automargin": True},
                        "height": 250,
                        "margin": {"t": 10, "l": 10, "r": 10},
                    },
                },
            )
            for column in ["count", "Percentage"]
        ]
    )

#if __name__ == '__main__':
app.run_server(mode='inline')

"""##2. Are stewards (steward activity measured by the ‘steward’ variable) having an impact on the health of trees?"""

app2 = JupyterDash(__name__)
#fig = px.histogram(soql_trees_assignment4, x="health", color="spc_common", barmode="group")
app2.layout = html.Div(children=[
    html.H1(children='Brian Singh_Assignment4_Data608_Question2'),

    html.Div(children='''
        Please select a steward category.
    '''),

        
        dcc.Dropdown(
            soql_trees_assignment4['steward'].unique(),
            id='stwd',
            value=soql_trees_assignment4.steward.values,
        ),

        dcc.Dropdown(
            soql_trees_assignment4['spc_common'].unique(),
            id='spc',
            value=soql_trees_assignment4.spc_common.values,
        ),

        dcc.Dropdown(
            soql_trees_assignment4['boroname'].unique(),
            id='boro',
            value=soql_trees_assignment4.boroname.values,
        ),

    dcc.Graph(
        id='graph',
        figure=fig
    )
])

@app2.callback(
    Output('graph','figure'),
    #Output('table','data'), #new
    Input('stwd','value'),
    Input('spc','value'),
    Input('boro','value')
)

def update_graph(stwd,spc,boro):
  df3 = soql_trees_assignment4
  fig = px.histogram(df3, x=df3["health"].loc[(df3["steward"]==stwd) & (df3["spc_common"]==spc) & (df3["boroname"]==boro)])
  return fig

app2.run_server(mode='inline')

"""## Conclusion

In the first set of code for #1, I was able to successfully implement dropdowns for the tree species and borough in order for the user to visually see the tree's health. I was unable to get the table to update with the same dropdown filters, however in code I found via the link referenced above for my second set of code, I was able to output the table of data and the ability to filter also filters the histograms.

For question #2, we can see that trees with no stewards have the most trees in good health, which is interesting. However, this could be due to the fact that a majority of trees do not have a steward assigned.
"""